AWSTemplateFormatVersion: 2010-09-09
# stage name of the API versions eg v1 for prod or v2 testing 
Parameters:
  StageName:
    Type: String
    Default: v1
    Description: Default used v1 API stage identifier

  # CF Parameter Authorizer Lambda function's handler
  LambdaHandler:
    Type: String
    # standard CJS handler name, index.handler,
    # with the inline code format required by ZipFile when the file is defaulted to index.js.
    Default: index.handler 
    Description: The entry point for the Lambda function 

Resources:
  # -------------------------------------------------------------------
  # Lambda authorizer resource declaration 
  # -------------------------------------------------------------------
  # IAM Role for the Lambda Authorizer function
  AuthorizerLambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole' # need for CloudWatch Logs
      Tags:
        - Key: Name
          Value: !Sub 'AuthorizerLambdaRole-${StageName}'
  # -------------------------------------------------------------------
  # Lambda function resource declaration 
  # -------------------------------------------------------------------
  # Lambda function with inline code (Node.js)
  AuthorizerLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub 'APIGatewayAuthorizer-${StageName}'
      Handler: !Ref LambdaHandler
      Role: !GetAtt AuthorizerLambdaExecutionRole.Arn
      # Runtime node CJS standard for compatibility
      Runtime: nodejs22.x 
      # inline code under Zipline property attribute
      Code:
        ZipFile: |
          // Includes async handler ... full token validation logic.
          exports.handler = async (event) => {
            
            const methodArn = event.methodArn;
            const EXPECTED_SECRET = "YOUR_SECRET_TOKEN"; // Bearer Token Secret change this to change Bearer Token

            // make varible tokenFromHeaders then Get token from standard API Gateway field
            // Handles case-insensitivity for 'authorization' header if present.
            // dont want .trim() function to fail 
            const tokenFromHeaders = event.headers?.authorization || event.headers?.Authorization || "";

            // event.authorizationToken (API GW) over header access methods above
            const fullToken = (event.authorizationToken || tokenFromHeaders || "").trim(); 
            
            let token = fullToken;
            // Extract the token part, removing "Bearer " if present
            if (fullToken.startsWith("Bearer ") || fullToken.startsWith("bearer ")) {
                token = fullToken.substring(7).trim(); // Remove "Bearer " prefix and trim again
            }
            
            // DIAGNOSTIC LOGGING
            //console.log("Full Event Token (pre-trim, pre-bearer):", fullToken);
            //console.log("Extracted Token for comparison:", token);
            //console.log("Expected Token:", EXPECTED_SECRET);
            
            try {
              // token validation logic
              if (token === EXPECTED_SECRET) {
                // ALLOW Policy
                console.log("Authorization Succeeded.");
                return { 
                  principalId: "user-id",
                  policyDocument: {
                    Version: "2012-10-17",
                    Statement: [
                      {
                        Action: "execute-api:Invoke",
                        Effect: "Allow",
                        Resource: methodArn,
                      },
                    ],
                  },
                  context: {
                    userId: "authenticated-user",
                  },
                };
              } else {
                // Deny by throwing "Unauthorized" (API Gateway standard response for Deny)
                console.error("Authorization FAILED: Token mismatch. Extracted: [%s], Expected: [%s]", token, EXPECTED_SECRET);
                throw new Error("Unauthorized");
              }
            } catch (error) {
              // Any error during execution (including the "Unauthorized" thrown above) 
              // will result in API Gateway denying access.
              console.error("Policy Generation/Validation Error:", error);
              // Return a Deny policy if the error is not 'Unauthorized' (though throwing 'Unauthorized' is preferred).
              throw new Error("Unauthorized"); 
            }
          };
      Timeout: 30
      MemorySize: 128
      Tags:
        - Key: Name
          Value: !Sub 'AuthorizerLambda-${StageName}'
  
  # API Gateway Authorizer resource
  ApiGatewayAuthorizer:
    Type: 'AWS::ApiGateway::Authorizer'
    Properties:
      # MUST be TOKEN or REQUEST type. TOKEN is standard for header-based auth.
      Type: TOKEN 
      # The name of the header where the token will be passed (e.g., 'Authorization')
      IdentitySource: method.request.header.Authorization 
      Name: CustomLambdaAuthorizer
      RestApiId: !Ref Api
      AuthorizerUri: !Sub
        # This URI format is specific for Lambda Authorizers in the current region
        - 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations'
        - LambdaArn: !GetAtt AuthorizerLambdaFunction.Arn
      # Caching interval in seconds. Set to 0 to disable caching for debugging
      AuthorizerResultTtlInSeconds: 0 
      # Relaxing the IdentityValidationExpression
      IdentityValidationExpression: '^Bearer .*' 

  # Permission for the API Gateway to invoke the Lambda Authorizer
  AuthorizerLambdaPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref AuthorizerLambdaFunction
      Principal: apigateway.amazonaws.com
      # SourceArn limits the permission to this specific REST API
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${Api}/*/*"

  # -------------------------------------------------------------------
  # API Gateway Resources 
  # -------------------------------------------------------------------
  # create resource ReqValidatorsSample API gateway -> REST API it will have all endpoints, methods and validators under it
  Api:
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Name: ReqValidatorsSample
      # Change to REGIONAL endpoint type instead of Edge optimized to bypass CloudFront header stripping.
      EndpointConfiguration:
        Types:
          - REGIONAL 
  # -------------------------------------------------------------------
  # Model for the Body json data this is index ID : type integer 
  # -------------------------------------------------------------------       
  # create resource model for Id for json schema of requests responses as REST API
  RequestBodyModelId:
    Type: 'AWS::ApiGateway::Model'
    Properties:
      RestApiId: !Ref Api
      ContentType: application/json
      # defining PetID as integer and as Model identifier RequestBodyModelId
      Description: Request body model for Pet ID.
      Schema:
        $schema: 'http://json-schema.org/draft-04/schema#'
        title: RequestBodyModelId
        properties:
            id:
              type: integer
  # -------------------------------------------------------------------
  # Model for the Body json data this is Pet type, name, price, and include ID above : type Object  
  # -------------------------------------------------------------------       
  # create resource model defining Pet request body data structure in json requests responses as REST API
  RequestBodyModel: 
    Type: 'AWS::ApiGateway::Model'
    Properties:
      RestApiId: !Ref Api
      ContentType: application/json
      # defining id, price, name and type as json data objects and validating constraints on the input data 
      # uses referencing feature for id object 
      Description: Request body model for Pet type, name, price, and ID.
      Schema:
        $schema: 'http://json-schema.org/draft-04/schema#'
        title: RequestBodyModel
        required:
          - price
          - name
          - type
        type: object
        properties:
            id:
              "$ref": !Sub 
                - 'https://apigateway.amazonaws.com/restapis/${Api}/models/${RequestBodyModelId}'
                - Api: !Ref Api
                  RequestBodyModelId: !Ref RequestBodyModelId
            # validation on object data : price inputs 25 thru 500, name is string, type is string dog OR cat OR fish
            price: 
              type: number
              minimum: 25
              maximum: 500
            name:
              type: string
            type:
              type: string
              enum:
                - "dog"
                - "cat"
                - "fish"
  # API gateway request checking using Type RequestValidator
  # the GETValidator for the GET method encoded requests 
  GETValidator:
    Type: AWS::ApiGateway::RequestValidator
    # check that encoded REST data in HTTP GET request exist as URL parameters
    # want API gateway to check the request so we can check this request syntax is met for GET requests
    Properties:
      # parameters encoded in HTTP get 
      Name: params-only
      RestApiId: !Ref Api
      # dont check body for parameter encoding in HTTP get
      # if get request has body encoded parameters API gateway will throw 403 error
      ValidateRequestBody: False
      # do check URL parameters for encoding in HTTP get and service request 
      ValidateRequestParameters: True 
  # the POSTValidator for the POST method encoded requests 
  POSTValidator:
    Type: AWS::ApiGateway::RequestValidator
    # check that encoded REST data in HTTP POST request exist as a body encoding of the parameters
    # want API gateway to check the request so we can check this request syntax is met for POST requests 
    Properties:
      # parameters encoded in HTTP post 
      Name: body-only
      RestApiId: !Ref Api
      # do check for body encoded request in HTTP POST and service request 
      ValidateRequestBody: True
      # if get request has URL get style encoded parameters API gateway will throw 403 error
      ValidateRequestParameters: False
      
  # Resource for GET and POST methods (restoring to /validation)
  ValidationResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref Api
      ParentId: !GetAtt Api.RootResourceId
      # define a Path for the URL called validation
      PathPart: 'validation'

  # -------------------------------------------------------------------
  # Update Existing Methods to use the Authorizer
  # -------------------------------------------------------------------

  # define HTTP method get call it ValidationMethodGet - uses /validation
  ValidationMethodGet:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref Api
      # Point to the shared resource
      ResourceId: !Ref ValidationResource
      HttpMethod: GET
      # Use the Lambda Authorizer
      AuthorizationType: CUSTOM 
      AuthorizerId: !Ref ApiGatewayAuthorizer
      # reference GETValidator 
      RequestValidatorId: !Ref GETValidator
      # declare that parameter query key is present called q1 it can be any value
      RequestParameters:
        method.request.querystring.q1: true
      # then Proxy the get query to endpoint demo petstore then we will return the data to api requestor 
      Integration:
        Type: HTTP_PROXY
        IntegrationHttpMethod: GET
        Uri: http://petstore-demo-endpoint.execute-api.com/petstore/pets/

  # define HTTP method post call it ValidationMethodPost - uses /validation
  ValidationMethodPost:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref Api
      # Point to the shared resource
      ResourceId: !Ref ValidationResource 
      HttpMethod: POST
      # Use the Lambda Authorizer
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiGatewayAuthorizer
      # reference POSTValidator
      RequestValidatorId: !Ref POSTValidator
      
      RequestModels:
        application/json : !Ref RequestBodyModel 
      # then Proxy the post query to endpoint demo petstore then we will return the data to api requestor
      Integration:
        Type: HTTP_PROXY
        IntegrationHttpMethod: POST
        Uri: http://petstore-demo-endpoint.execute-api.com/petstore/pets/
        # static Content-Type mapping to satisfy the upstream API.
        RequestParameters:
          integration.request.header.Content-Type: "'application/json'"
        # Map the request body to ensure it is forwarded in the proxy integration, 
        # as defining RequestModels can interfere with the default proxy passthrough.
        RequestTemplates:
          application/json: "$input.body"
          
  # deployment of the API gateway resource and REST API request forwarding to petstore demo API
  ApiDeployment:
    Type: 'AWS::ApiGateway::Deployment'
    # DependsOn helps resource instanciation to complete in defined sequence 
    DependsOn:
      - ValidationMethodGet
      - ValidationMethodPost
      - ApiGatewayAuthorizer
      - RequestBodyModel 
      - RequestBodyModelId 
    Properties:
      RestApiId: !Ref Api
      StageName: !Sub '${StageName}'
# Show cloudformation output the URI of the API gateway to make calls on
Outputs:
  ApiRootUrl:
    Description: Root Url of the API
    Value: !Sub 'https://${Api}.execute-api.${AWS::Region}.amazonaws.com/${StageName}'
  AuthorizerLambdaArn:
    Description: ARN of the Lambda function acting as the Authorizer.
    Value: !GetAtt AuthorizerLambdaFunction.Arn
